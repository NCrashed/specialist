\begin{haskellpragmas}
{-# LANGUAGE OverloadedStrings #-}
\end{haskellpragmas}
\begin{writehaskell}
import Common

weightedArch f = f [
    ("Сложность реализации", 0.3)
  , ("Удобство пользователя", 0.2)
  , ("Безопасность", 0.15)
  , ("Масштабируемость", 0.15)
  , ("Сложность интеграции", 0.2)] 
  [ ("Монолит",       [5, 2, 2, 1, 1])
  , ("Файл-сервер",   [3, 3, 3, 2, 3])
  , ("Клиент-сервер", [3, 5, 4, 4, 4])
  , ("Облако",        [2, 5, 3, 5, 5])]

weightedClientLang f = f [
    ("Простота разработки", 0.3)
  , ("Производительность", 0.3)
  , ("Cообщество", 0.2)
  , ("Риски проектирования", 0.2)] 
  [ ("JavaScript", [2, 5, 5, 5])
  , ("Haskell",    [5, 2, 4, 5])
  , ("PureScript", [4, 4, 3, 3])
  , ("Elm",        [3, 4, 4, 2])]

\end{writehaskell}

\subsubsection{Разработка архитектуры АИС} 

\paragraph{Выбор архитектуры приложения}

В процессе проектирования были рассмотрены несколько вариантов архитектуры АИС:
\begin{itemize}
\item Монолитное клиентское приложение (рис.~\ref{figure:archMono}) -- АИС состоит из единственного приложения, которое выполняет все функции АИС. Данное приложение устанавливается на ЭВМ пользователя и хранит все данные локально.
\item Файловый сервер (рис.~\ref{figure:fileServer}) -- АИС состоит из приложения на ЭВМ пользователя и двух серверов, расположенные на удалённых машинах: СУБД и текстового индексатора.
\item Клиент-сервер (рис.~\ref{figure:clientServer}) -- АИС состоит из тонкого веб-приложения, запускаемого на терминале пользователя, сервера приложений, сервера СУБД и сервера индексатора. 
\item Облачная архитектура (рис.~\ref{figure:archCloud}) -- АИС состоит из тонкого веб-приложения и набора серверов-узлов. Каждый узел облака не имеет постоянной специализации и одновременно выполняет функции АИС, связанные с хранением данных, построения полнотекстового индекса и вычисления бизнес-логики отдельных модулей.
\end{itemize}

Критерии оценки архитектуры:
\begin{enumerate}
\item Сложность реализации -- трудоемкость проектирования, кодирования и отладки архитектуры. Чрезмерная сложность реализации может служить причиной отказа от конкретного вида архитектуры.
\item Удобство пользователя -- интегральный показатель, который включает в себя:
\begin{itemize}
\item Необходимость производительной машины у пользователя. Архитектура, которая не требует от клиентских машин значительных ресурсов, является предпочтительной.
\item Доступность системы для пользователя -- возможно ли использование системы удалённо, с нескольких устройств.
\item Удобство миграции данных -- сложность переноса данных при смене устройства пользователя.
\end{itemize}
\item Безопасность -- уровень безопасности, который можно достигнуть с данной архитектурой при умеренных трудозатратах. 
\item Масштабируемость -- сложность расширения системы при нарастании объемов обрабатываемых данных.
\item Сложность интеграции -- трудозатраты по интеграции системы в более сложные комплексы. Выделенные сервера СУБД позволяют легче интегрировать и поддерживать АИС. Но при этом слишком большое число машин усложняет интеграцию АИС в другие комплексы.
\end{enumerate}

\clearpage
\subparagraph{Монолитная архитектура} \hfill

\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{design/archMono}
\caption{Монолитное клиентское приложение}
\label{figure:archMono}
\end{figure}

Монолитная архитектура является самой простой для реализации, так как исключается сетевое взаимодействие между компонентами АИС. СУБД может быть реализована как локальное файловое хранилище, индексатор текстов как внутренний модуль приложения. 

Однако монолитная архитектура является неудобной для пользователя, так как требует мощной ЭВМ для работы. При сбоях работы ЭВМ пользователя данные системы теряются. Также в данной архитектуре сложно достичь достаточного уровня безопасности данных пользователя.

\clearpage
\subparagraph{Архитектура файл-сервер} \hfill

\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{design/fileServer}
\caption{Архитектура файл-сервер}
\label{figure:fileServer}
\end{figure}

Архитектура файл-сервер является переходной между трехуровневой (клиент-сервер) и монолитной архитектурами. Данный вариант сочетает относительную легкость проектирования и удобство использования, так как данные приложения хранятся на отдельном сервере и не будут потеряны при сборе на машине пользователя. 

Однако в данном варианте все еще требуется производительная ЭВМ у пользователя, а при разработке все еще нужно учитывать особенности платформы ЭВМ пользователя. Также большинство библиотек специализируются на архитектуре клиент-сервер, что повышает сложность реализации такой архитектуры.

\clearpage
\subparagraph{Архитектура клиент-сервер} \hfill

\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{design/clientServer}
\caption{Архитектура клиент-сервер}
\label{figure:clientServer}
\end{figure}

В данном варианте архитектуры клиентская машина может быть непроизводительной, так как вся бизнес-логика приложения выполняется на сервере приложений. Относительно легко реализовывать клиент-сервер, так как большинство библиотек заточено на данную архитектуру. Также данная архитектура позволяет реализовать сочетание безопасности данных с их доступностью для пользователя. 

Единственный существенный недостаток этот архитектуры в сложности горизонтальной масштабируемости и фиксируемой ролью каждой машины в АИС, что усложняет эффективное использование суммарной производительности системы. 

\clearpage
\subparagraph{Облачная архитектура} \hfill

\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{design/archCloud}
\caption{Облачная архитектура АИС}
\label{figure:archCloud}
\end{figure}

Облачная архитектура использует гораздо более высокий уровень абстракции, чем все предыдущие архитектуры, так как код приложения не привязан к ЭВМ, на которой он будет выполняться, и может мигрировать между серверами по мере надобности для достижения равномерной загрузки кластера серверов. 

Недостатками данной архитектуры является очень высокая сложность реализации и сложность обеспечения безопасности данных.

\clearpage
\subparagraph{Сравнение вариантов архитектуры АИС} \hfill

\begin{table}[h!]
\centering
\caption{Сравнение вариантов архитектуры АИС}
\label{table:archChoice}
\hatex{weightedArch weightedSummTabular}
\end{table}

\begin{table}[h!]
\centering
\caption{Сравнение вариантов архитектуры АИС с нормированными оценками}
\label{table:archChoiceNorm}
\hatex{weightedArch weightedSummTabular'}
\end{table}

Таким образом из таблицы~\ref{table:archChoiceNorm} видно, что следует реализовать архитектуру клиент-сервер.

\paragraph{Выбор клиентского языка программирования} \hfill

В результате выбора клиент-серверной архитектуры структура АИС с точки зрения технологий программирования разбивается на клиентскую и серверную части. Произведем выбор языка программирования клиентской части. 

Рассмотрим следующие языки программирования:
\begin{itemize}
\item JavaScript -- основной язык программирования для браузерных клиентов. Сочетает простоту и скорость выполнения, однако имеет несколько недостатков: динамическая типизация и ориентированность на императивную парадигму программирования. Также имеются проблемы с моделированием многопоточных приложений.
\item Haskell -- компиляция в JavaScript через GHCJS. Имеет преимущества чистого функционального языка программирования с продуманным дизайном. Основной недостаток -- сомнительная производительность и человеко-читаемость результата компиляции.
\item PureScript -- чистый функциональный язык с компиляцией в JavasSript, вдохновленный языком Haskell. Имеет человеко-читаемый результат компиляции и предсказуемую производительность. Недостатками являются более малый набор возможностей, чем имеется у Haskell, а также нестабильность инфраструктуры. Имеет малочисленное сообщество.
\item Elm -- чистый функциональный язык с компиляцией в JavaScript. Имеет встроенную парадигму FRP и удобные инструменты отладки. Имеет малочисленное сообщество и является нестабильным. Декларируемый подход <<одна идея -- один способ реализации>> является проектным риском, так как разработчик может столкнуться с невозможностью реализации отдельных частей разработанной архитектуры АИС. 
\end{itemize}

Используемые критерии оценки:
\begin{itemize}
\item Простота разработки -- трудозатраты на написание качественного и легко поддерживаемого кода.
\item Производительность -- производительность генерируемого JavaScript кода из языков производных от него.
\item Размер и активность сообщества -- чем больше и активнее сообщество, тем больше вероятность быстро решить возникающие проблемы и тем больше переиспользование существующих решений.
\item Риски проектирования -- вероятность встретить неразрешимые проблемы в реализации языка или его реализации, в результате которых придется переключиться на другой язык.
\end{itemize}

\begin{table}[h!]
\centering
\caption{Сравнение вариантов выбора клиентского языка программирования}
\label{table:clientLanguageChoice}
\hatex{weightedClientLang weightedSummTabular}
\end{table}

\begin{table}[h!]
\centering
\caption{Сравнение вариантов выбора клиентского языка программирования с нормированными оценками}
\label{table:clientLanguageChoiceNorm}
\hatex{weightedClientLang weightedSummTabular'}
\end{table}

По таблице~\ref{table:clientLanguageChoiceNorm} видно, что лучшим выбором будет язык JavaScript, который будет сочетать производительность и вероятность помощи от сообщества при приемлемых затратах на качественную разработку.

\paragraph{Выбор библиотеки для рубрикатора} \hfill

\paragraph{Выбор библиотеки для графиков} \hfill

\paragraph{Выбор серверного языка программирования} \hfill

\paragraph{Выбор серверной библиотеки} \hfill

\paragraph{Выбор СУБД} \hfill
