\begin{haskellpragmas}
{-# LANGUAGE OverloadedStrings #-}
\end{haskellpragmas}
\begin{writehaskell}
import Common

weightedArch f = f [
    ("Сложность реализации", 0.3)
  , ("Удобство пользователя", 0.2)
  , ("Безопасность", 0.15)
  , ("Масштабируемость", 0.15)
  , ("Сложность интеграции", 0.2)] 
  [ ("Монолит",       [5, 2, 2, 1, 1])
  , ("Файл-сервер",   [3, 3, 3, 2, 3])
  , ("Клиент-сервер", [3, 5, 4, 4, 4])
  , ("Облако",        [2, 5, 3, 5, 5])]

weightedClientLang f = f [
    ("Простота разработки", 0.3)
  , ("Производительность", 0.3)
  , ("Cообщество", 0.2)
  , ("Риски проектирования", 0.2)] 
  [ ("JavaScript", [2, 5, 5, 5])
  , ("Haskell",    [5, 2, 4, 5])
  , ("PureScript", [4, 4, 3, 3])
  , ("Elm",        [3, 4, 4, 2])]

weightedServerLang f = f [
    ("Простота разработки", 0.4)
  , ("Производительность", 0.1)
  , ("Скорость компиляции", 0.05)
  , ("Легкость освоения", 0.1)
  , ("Безопасность", 0.2)
  , ("Размер и активность сообщества", 0.05)
  , ("Риски проектирования", 0.1) ]
  [ ("C++",     [2, 5, 2, 4, 3, 4, 5])
  , ("Java",    [3, 4, 5, 5, 3, 5, 5])
  , ("Scala",   [4, 3, 1, 4, 4, 3, 4])
  , ("Haskell", [5, 4, 2, 5, 4, 4, 4])
  , ("Idris",   [5, 3, 3, 3, 5, 2, 1]) ]

weightedServerLibrary f = f [
    ("Легковесность", 0.1)
  , ("Количество библиотек", 0.2)
  , ("Сложность разработки", 0.4)
  , ("Производительность", 0.3) ]
  [ ("Happstack", [4, 3, 4, 3])
  , ("Snap",      [4, 4, 4, 5])
  , ("Yesod",     [2, 5, 5, 4])
  , ("Servant",   [5, 3, 5, 4])]

weightedServerDB f = f [
    ("Интеграция в Haskell", 0.3)
  , ("Производительность", 0.2)
  , ("Качество документации", 0.1)
  , ("Распространённость", 0.1)
  , ("Масштабируемость", 0.2)
  , ("Возможности языка запросов", 0.0) ]
  [ ("PostgreSQL", [5, 5, 4, 5, 3, 5])
  , ("MySQL",      [5, 3, 2, 4, 2, 3])
  , ("MongoDB",    [4, 4, 4, 5, 5, 4])
  , ("Acid-State", [5, 4, 4, 1, 3, 5]) ]

\end{writehaskell}

\subsubsection{Разработка архитектуры АИС} 

\paragraph{Выбор архитектуры приложения}

В процессе проектирования были рассмотрены несколько вариантов архитектуры АИС:
\begin{itemize}
\item Монолитное клиентское приложение (рис.~\ref{figure:archMono}) -- АИС состоит из единственного приложения, которое выполняет все функции АИС. Данное приложение устанавливается на ЭВМ пользователя и хранит все данные локально.
\item Файловый сервер (рис.~\ref{figure:fileServer}) -- АИС состоит из приложения на ЭВМ пользователя и двух серверов, расположенные на удалённых машинах: СУБД и текстового индексатора.
\item Клиент-сервер (рис.~\ref{figure:clientServer}) -- АИС состоит из тонкого веб-приложения, запускаемого на терминале пользователя, сервера приложений, сервера СУБД и сервера индексатора. 
\item Облачная архитектура (рис.~\ref{figure:archCloud}) -- АИС состоит из тонкого веб-приложения и набора серверов-узлов. Каждый узел облака не имеет постоянной специализации и одновременно выполняет функции АИС, связанные с хранением данных, построения полнотекстового индекса и вычисления бизнес-логики отдельных модулей.
\end{itemize}

Критерии оценки архитектуры:
\begin{enumerate}
\item Сложность реализации -- трудоемкость проектирования, кодирования и отладки архитектуры. Чрезмерная сложность реализации может служить причиной отказа от конкретного вида архитектуры.
\item Удобство пользователя -- интегральный показатель, который включает в себя:
\begin{itemize}
\item Необходимость производительной машины у пользователя. Архитектура, которая не требует от клиентских машин значительных ресурсов, является предпочтительной.
\item Доступность системы для пользователя -- возможно ли использование системы удалённо, с нескольких устройств.
\item Удобство миграции данных -- сложность переноса данных при смене устройства пользователя.
\end{itemize}
\item Безопасность -- уровень безопасности, который можно достигнуть с данной архитектурой при умеренных трудозатратах. 
\item Масштабируемость -- сложность расширения системы при нарастании объемов обрабатываемых данных.
\item Сложность интеграции -- трудозатраты по интеграции системы в более сложные комплексы. Выделенные сервера СУБД позволяют легче интегрировать и поддерживать АИС. Но при этом слишком большое число машин усложняет интеграцию АИС в другие комплексы.
\end{enumerate}

\clearpage
\subparagraph{Монолитная архитектура} \hfill

\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{design/archMono}
\caption{Монолитное клиентское приложение}
\label{figure:archMono}
\end{figure}

Монолитная архитектура является самой простой для реализации, так как исключается сетевое взаимодействие между компонентами АИС. СУБД может быть реализована как локальное файловое хранилище, индексатор текстов как внутренний модуль приложения. 

Однако монолитная архитектура является неудобной для пользователя, так как требует мощной ЭВМ для работы. При сбоях работы ЭВМ пользователя данные системы теряются. Также в данной архитектуре сложно достичь достаточного уровня безопасности данных пользователя.

\clearpage
\subparagraph{Архитектура файл-сервер} \hfill

\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{design/fileServer}
\caption{Архитектура файл-сервер}
\label{figure:fileServer}
\end{figure}

Архитектура файл-сервер является переходной между трехуровневой (клиент-сервер) и монолитной архитектурами. Данный вариант сочетает относительную легкость проектирования и удобство использования, так как данные приложения хранятся на отдельном сервере и не будут потеряны при сборе на машине пользователя. 

Однако в данном варианте все еще требуется производительная ЭВМ у пользователя, а при разработке все еще нужно учитывать особенности платформы ЭВМ пользователя. Также большинство библиотек специализируются на архитектуре клиент-сервер, что повышает сложность реализации такой архитектуры.

\clearpage
\subparagraph{Архитектура клиент-сервер} \hfill

\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{design/clientServer}
\caption{Архитектура клиент-сервер}
\label{figure:clientServer}
\end{figure}

В данном варианте архитектуры клиентская машина может быть непроизводительной, так как вся бизнес-логика приложения выполняется на сервере приложений. Относительно легко реализовывать клиент-сервер, так как большинство библиотек заточено на данную архитектуру. Также данная архитектура позволяет реализовать сочетание безопасности данных с их доступностью для пользователя. 

Единственный существенный недостаток этот архитектуры в сложности горизонтальной масштабируемости и фиксируемой ролью каждой машины в АИС, что усложняет эффективное использование суммарной производительности системы. 

\clearpage
\subparagraph{Облачная архитектура} \hfill

\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{design/archCloud}
\caption{Облачная архитектура АИС}
\label{figure:archCloud}
\end{figure}

Облачная архитектура использует гораздо более высокий уровень абстракции, чем все предыдущие архитектуры, так как код приложения не привязан к ЭВМ, на которой он будет выполняться, и может мигрировать между серверами по мере надобности для достижения равномерной загрузки кластера серверов. 

Недостатками данной архитектуры является очень высокая сложность реализации и сложность обеспечения безопасности данных.

\clearpage
\subparagraph{Сравнение вариантов архитектуры АИС} \hfill

\begin{table}[h!]
\centering
\caption{Сравнение вариантов архитектуры АИС}
\label{table:archChoice}
\hatex{weightedArch weightedSummTabular}
\end{table}

\begin{table}[h!]
\centering
\caption{Сравнение вариантов архитектуры АИС с нормированными оценками}
\label{table:archChoiceNorm}
\hatex{weightedArch weightedSummTabular'}
\end{table}

Таким образом из таблицы~\ref{table:archChoiceNorm} видно, что следует реализовать архитектуру клиент-сервер.

\paragraph{Выбор клиентского языка программирования} \hfill

В результате выбора клиент-серверной архитектуры структура АИС с точки зрения технологий программирования разбивается на клиентскую и серверную части. Произведем выбор языка программирования клиентской части. 

Рассмотрим следующие языки программирования:
\begin{itemize}
\item JavaScript -- основной язык программирования для браузерных клиентов. Сочетает простоту и скорость выполнения, однако имеет несколько недостатков: динамическая типизация и ориентированность на императивную парадигму программирования. Также имеются проблемы с моделированием многопоточных приложений.
\item Haskell -- компиляция в JavaScript через GHCJS. Имеет преимущества чистого функционального языка программирования с продуманным дизайном. Основной недостаток -- сомнительная производительность и человеко-читаемость результата компиляции.
\item PureScript -- чистый функциональный язык с компиляцией в JavasSript, вдохновленный языком Haskell. Имеет человеко-читаемый результат компиляции и предсказуемую производительность. Недостатками являются более малый набор возможностей, чем имеется у Haskell, а также нестабильность инфраструктуры. Имеет малочисленное сообщество.
\item Elm -- чистый функциональный язык с компиляцией в JavaScript. Имеет встроенную парадигму FRP и удобные инструменты отладки. Имеет малочисленное сообщество и является нестабильным. Декларируемый подход <<одна идея -- один способ реализации>> является проектным риском, так как разработчик может столкнуться с невозможностью реализации отдельных частей разработанной архитектуры АИС. 
\end{itemize}

Используемые критерии оценки:
\begin{itemize}
\item Простота разработки -- трудозатраты на написание качественного и легко поддерживаемого кода.
\item Производительность -- производительность генерируемого JavaScript кода из языков производных от него.
\item Размер и активность сообщества -- чем больше и активнее сообщество, тем больше вероятность быстро решить возникающие проблемы и тем больше переиспользование существующих решений.
\item Риски проектирования -- вероятность встретить неразрешимые проблемы в реализации языка или его реализации, в результате которых придется переключиться на другой язык.
\end{itemize}

\begin{table}[h!]
\centering
\caption{Сравнение вариантов выбора клиентского языка программирования}
\label{table:clientLanguageChoice}
\hatex{weightedClientLang weightedSummTabular}
\end{table}

\begin{table}[h!]
\centering
\caption{Сравнение вариантов выбора клиентского языка программирования с нормированными оценками}
\label{table:clientLanguageChoiceNorm}
\hatex{weightedClientLang weightedSummTabular'}
\end{table}

По таблице~\ref{table:clientLanguageChoiceNorm} видно, что лучшим выбором будет язык JavaScript, который будет сочетать производительность и вероятность помощи от сообщества при приемлемых затратах на качественную разработку.

\paragraph{Выбор серверного языка программирования} \hfill

В качестве серверного языка программирования были рассмотрены следующие варианты:
\begin{itemize}
\item C++ -- широко распространенный объектно-ориентированный компилируемый язык системного программирования. С его помощью легко достичь хорошей производительности программ, но сложно создать качественную программу с отсутствием уязвимостей.
\item Java -- широко распространенный объектно-ориентированный язык прикладного программирования, который используется для серверного программирования в большом числе корпораций. Данный язык прост в освоении, на нем легче разрабатывать приложения с высокой безопасностью, и имеет достаточную производительность. Однако его система типизации является ограниченной и мешает реализации сложных абстракций.
\item Scala -- новый функциональный язык программирования на основе инфраструктуры Java. Вводит высокоуровневую систему типов, но является сложным в освоении и имеет меньшую производительность. Из недостатков замечена также очень долгая компиляция исходников.
\item Haskell -- зрелый функциональный язык программирования с хорошо спроектированной системой типов, ленивой семантикой и хорошей производительностью. Недостатки: сложность освоения, длительность компиляции.
\item Idris -- новейший функциональный язык с зависимой типизацией и проверкой тотальности программы. Основным преимуществом языка является возможность написания программ с математически доказанными фактами отсутствия уязвимостей или ошибок. Но данный язык находится в стадии разработки и является очень сложным для освоения.
\end{itemize}

В качестве критериев оценки были выбраны следующие параметры:
\begin{itemize}
\item Простота разработки -- трудозатраты на написание качественного и легко поддерживаемого кода. Сюда также включаются особенности системы типов и семантики выполнения программы.
\item Производительность -- производительность генерируемого кода, простота получения производительных программ. 
\item Скорость компиляции -- время, затрачиваемое на компиляцию исходных кодов программы в машинный язык или байткод.
\item Легкость освоения -- трудозатраты на освоение языка программирования до необходимого для поддержки и разработки уровня. Здесь учитываются только предстоящие трудозатраты на освоение или дополнительного изучения языка.
\item Безопасность -- трудозатраты на разработку программ с хорошим уровнем защищенности.
\item Размер и активность сообщества -- чем больше и активнее сообщество, тем больше вероятность быстро решить возникающие проблемы и тем больше переиспользование существующих решений.
\item Риски проектирования -- вероятность встретить неразрешимые проблемы в реализации языка или его реализации, в результате которых придется переключиться на другой язык.
\end{itemize}

\begin{table}[h!]
\centering
\caption{Сравнение вариантов выбора серверного языка программирования}
\label{table:serverLanguageChoice}
\hatex{weightedServerLang weightedSummTabular}
\end{table}

\begin{table}[h!]
\centering
\caption{Сравнение вариантов выбора серверного языка программирования с нормированными оценками}
\label{table:serverLanguageChoiceNorm}
\hatex{weightedServerLang weightedSummTabular'}
\end{table}

Из таблицы~\ref{table:serverLanguageChoiceNorm} видно, что оптимальным выбором будет язык программирования Haskell. 

\paragraph{Выбор серверной библиотеки} \hfill

Для языка Haskell имеется множество библиотек и фреймворков для серверного программирования, для использования в данной АИС рассмотрим следующие варианты:
\begin{itemize}
\item Happstack -- легковесная библиотека с использованием Template Haskell, хорошей производительностью и широким набором возможностей. Но данная библиотека не развивается в данный момент.
\item Snap -- легковесная библиотека с высокой производительностью и нацеленностью на модульность архитектуры. Недостатки: меньшая распространённость по сравнению с аналогами.
\item Yesod -- тяжеловесный фреймворк для комплексной web разработки. Имеет большую базу готовых решений и распространённость. Недостатки: сложность изучения и громоздкость.
\item Servant -- легковесная библиотека, основным преимуществом которой является перевод API приложений на уровень типов, что автоматизирует создание документации, автоматическую генерацию клиентских библиотек, повышает композируемость и безопасность приложений.
\end{itemize}

В качестве критериев оценки были выбраны следующие параметры:
\begin{itemize}
\item Легковесность -- легковесные библиотеки легче изучать, и легче повторно использовать готовые решения. 
\item Количество библиотек -- количество разных готовых решений значительно понижает трудозатраты на разработку приложений. 
\item Сложность разработки -- интегральный показатель количества трудозатрат, который учитывает автоматизацию рутинных действий, гибкость архитектуры библиотеки вместе с обнаружением проблем на ранних этапах разработки.
\item Производительность -- производительность серверной библиотеки является основой для производительности приложений, построенных на ее основе.
\end{itemize}

\begin{table}[h!]
\centering
\caption{Сравнение вариантов выбора серверного библиотеки}
\label{table:serverLibraryChoice}
\hatex{weightedServerLibrary weightedSummTabular}
\end{table}

\begin{table}[h!]
\centering
\caption{Сравнение вариантов выбора серверного библиотеки с нормированными оценками}
\label{table:serverLibraryChoiceNorm}
\hatex{weightedServerLibrary weightedSummTabular'}
\end{table}

Из таблицы~\ref{table:serverLibraryChoiceNorm} видно, что лучшим вариантом для серверной библиотеки является Yesod, не смотря на его громоздкость.

\paragraph{Выбор СУБД} \hfill

После выбора серверной библиотеки необходимо определиться с СУБД, варианты выбора СУБД должны согласовываться с выбором серверной библиотеки. Выбор производится из следующих вариантов:
\begin{itemize}
\item PostgreSQL -- реляционная СУБД. Преимущества: соответствие стандартам, подробная документация, хорошая масштабируемость. Недостатки: сложность настройки и освоения.
\item MySQL -- реляционная СУБД. Преимущества: простота настройки. Недостатки: несоответствие стандартам, проблемы с репликациями, слабая документация, проблемы с многобайтовыми кодировками.
\item MongoDB -- no-SQL СУБД на основе парадигмы <<ключ-значение>>. Преимущество: легкость масштабирования и простота модели данных. Недостатки: слабый язык запросов и слабая интеграция в Haskell.
\item Acid-State -- no-SQL СУБД, построенная как библиотека на языке Haskell, предоставляющая монадоидический API для управления транзакциями и обработки данных. Основные преимущества: простота и интеграция в Haskell. Недостатки: малоизвестная модель данных и проблемы с масштабированием.
\end{itemize}

В качестве критериев оценки были выбраны:
\begin{itemize}
\item Интеграция в Haskell -- качество библиотек для взаимодействия Haskell и рассматриваемой библиотекой. Для SQL СУБД и MongoDB есть общая библиотека Haskell Persistent.
\item Производительность -- производительность СУБД является <<бутылочным горлышком>> производительности всего приложения.
\item Качество документации -- качество документации напрямую влияет на время, потраченное на тестирование и исправление ошибок.
\item Распространённость -- чем больше распространена СУБД или ее модель хранения данных, тем легче проводить миграции и поддерживать АИС во время эксплуатации.
\item Масштабируемость -- количество трудозатрат для горизонтального масштабирования АИС. Сложности с масштабируемостью всего АИС зачастую упираются в сложность масштабирования СУБД.
\item Возможности языка запросов -- мощный язык запросов позволяет перенести часть нагрузки на СУБД и лучше использовать ресурсы системы.
\end{itemize}

\begin{table}[h!]
\centering
\caption{Сравнение вариантов выбора СУБД}
\label{table:serverDBChoice}
\hatex{weightedServerDB weightedSummTabular}
\end{table}

\begin{table}[h!]
\centering
\caption{Сравнение вариантов выбора СУБД с нормированными оценками}
\label{table:serverDBChoiceNorm}
\hatex{weightedServerDB weightedSummTabular'}
\end{table}

Из таблицы~\ref{table:serverDBChoiceNorm} видно, что лучшим вариантом для серверной библиотеки является PostgreSQL.
