\begin{haskellpragmas}
{-# LANGUAGE OverloadedStrings #-}
\end{haskellpragmas}
\begin{writehaskell}
import Common

type Variant = Text 
type Factor = Text 

weightedSummTabular :: [(Factor, Double)] -> [(Variant, [Int])] -> LaTeX
weightedSummTabular factors datum = tabular (Just Center) (LeftColumn:variantCols) $
  ("Критерии" & foldr1 (&) (footnotesize . raw . fst <$> datum)) <> lnbk <> hline <> hline
    <> mconcat rows
  where 
    variantCols = concat $ (const [VerticalLine, CenterColumn]) <$> datum
    rows = mkrow <$> [0 .. length factors - 1]
    isLast i = i == length factors - 1
    mkrow i = (raw (fst $ factors !! i) & (foldr1 (&) $ showr.(!! i).snd <$> datum)) <> lnbk <> (if isLast i then mempty else hline)

weightedSummTabular' :: [(Factor, Double)] -> [(Variant, [Int])] -> LaTeX
weightedSummTabular' factors datum = tabular (Just Center) (LeftColumn:VerticalLine:CenterColumn:VerticalLine:variantCols) $
  ("Критерии" & raw "$\\alpha$" & foldr1 (&) (footnotesize . raw . fst <$> datum)) <> lnbk <> hline <> hline
    <> mconcat rows
    <> lastRow 
  where 
    datum' = fmap normalize . snd <$> datum
    variantCols = concat $ (const [VerticalLine, CenterColumn]) <$> datum
    rows = mkrow <$> [0 .. length factors - 1]
    isLast i = i == length factors - 1
    mkrow i = (raw (fst $ factors !! i) 
      & (showf . snd $ factors !! i)
      & mkrow' i)
      <> lnbk <> hline <> (if isLast i then hline else mempty)
    mkrow' i = foldr1 (&) $ showf.(!! i) <$> datum'

    lastRow = ("Итого" & showf sumFacts & sumRows) <> lnbk
    sumFacts = sum $ snd <$> factors
    sumRows = foldr1 (&) $ fmap stressMaxVal sumRowsVals
    sumRowsVals = (sum . zipWith (*) (fmap snd factors)) <$> datum'
    maxVal = maximum sumRowsVals
    stressMaxVal v = if v == maxVal then textbf $ showf v else showf v
    normalize v = case v of 
      1 -> 0
      2 -> 0.25
      3 -> 0.5 
      4 -> 0.75
      5 -> 1
      _ -> 1

weightedArch f = f [
    ("Сложность реализации", 0.3)
  , ("Удобство пользователя", 0.2)
  , ("Безопасность", 0.15)
  , ("Масштабируемость", 0.15)
  , ("Сложность интеграции", 0.2)] 
  [ ("Монолит",       [5, 2, 2, 1, 1])
  , ("Файл-сервер",   [3, 3, 3, 2, 3])
  , ("Клиент-сервер", [3, 5, 4, 4, 4])
  , ("Облако",        [2, 5, 3, 5, 5])]
-- $
\end{writehaskell}

\subsubsection{Разработка архитектуры АИС} 

\paragraph{Выбор архитектуры приложения}

В процессе проектирования были рассмотрены несколько вариантов архитектуры АИС:
\begin{itemize}
\item Монолитное клиентское приложение (рис.~\ref{figure:archMono}) -- АИС состоит из единственного приложения, которое выполняет все функции АИС. Данное приложение устанавливается на ЭВМ пользователя и хранит все данные локально.
\item Файловый сервер (рис.~\ref{figure:fileServer}) -- АИС состоит из приложения на ЭВМ пользователя и двух серверов, расположенные на удалённых машинах: СУБД и текстового индексатора.
\item Клиент-сервер (рис.~\ref{figure:clientServer}) -- АИС состоит из тонкого веб-приложения, запускаемого на терминале пользователя, сервера приложений, сервера СУБД и сервера индексатора. 
\item Облачная архитектура (рис.~\ref{figure:archCloud}) -- АИС состоит из тонкого веб-приложения и набора серверов-узлов. Каждый узел облака не имеет постоянной специализации и одновременно выполняет функции АИС, связанные с хранением данных, построения полнотекстового индекса и вычисления бизнес-логики отдельных модулей.
\end{itemize}

Критерии оценки архитектуры:
\begin{enumerate}
\item Сложность реализации -- трудоемкость проектирования, кодирования и отладки архитектуры. Чрезмерная сложность реализации может служить причиной отказа от конкретного вида архитектуры.
\item Удобство пользователя -- интегральный показатель, который включает в себя:
\begin{itemize}
\item Необходимость производительной машины у пользователя. Архитектура, которая не требует от клиентских машин значительных ресурсов, является предпочтительной.
\item Доступность системы для пользователя -- возможно ли использование системы удалённо, с нескольких устройств.
\item Удобство миграции данных -- сложность переноса данных при смене устройства пользователя.
\end{itemize}
\item Безопасность -- уровень безопасности, который можно достигнуть с данной архитектурой при умеренных трудозатратах. 
\item Масштабируемость -- сложность расширения системы при нарастании объемов обрабатываемых данных.
\item Сложность интеграции -- трудозатраты по интеграции системы в более сложные комплексы. Выделенные сервера СУБД позволяют легче интегрировать и поддерживать АИС. Но при этом слишком большое число машин усложняет интеграцию АИС в другие комплексы.
\end{enumerate}

\clearpage
\subparagraph{Монолитная архитектура} \hfill

\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{design/archMono}
\caption{Монолитное клиентское приложение}
\label{figure:archMono}
\end{figure}

Монолитная архитектура является самой простой для реализации, так как исключается сетевое взаимодействие между компонентами АИС. СУБД может быть реализована как локальное файловое хранилище, индексатор текстов как внутренний модуль приложения. 

Однако монолитная архитектура является неудобной для пользователя, так как требует мощной ЭВМ для работы. При сбоях работы ЭВМ пользователя данные системы теряются. Также в данной архитектуре сложно достичь достаточного уровня безопасности данных пользователя.

\clearpage
\subparagraph{Архитектура файл-сервер} \hfill

\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{design/fileServer}
\caption{Архитектура файл-сервер}
\label{figure:fileServer}
\end{figure}

Архитектура файл-сервер является переходной между трехуровневой (клиент-сервер) и монолитной архитектурами. Данный вариант сочетает относительную легкость проектирования и удобство использования, так как данные приложения хранятся на отдельном сервере и не будут потеряны при сборе на машине пользователя. 

Однако в данном варианте все еще требуется производительная ЭВМ у пользователя, а при разработке все еще нужно учитывать особенности платформы ЭВМ пользователя. Также большинство библиотек специализируются на архитектуре клиент-сервер, что повышает сложность реализации такой архитектуры.

\clearpage
\subparagraph{Архитектура клиент-сервер} \hfill

\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{design/clientServer}
\caption{Архитектура клиент-сервер}
\label{figure:clientServer}
\end{figure}

В данном варианте архитектуры клиентская машина может быть непроизводительной, так как вся бизнес-логика приложения выполняется на сервере приложений. Относительно легко реализовывать клиент-сервер, так как большинство библиотек заточено на данную архитектуру. Также данная архитектура позволяет реализовать сочетание безопасности данных с их доступностью для пользователя. 

Единственный существенный недостаток этот архитектуры в сложности горизонтальной масштабируемости и фиксируемой ролью каждой машины в АИС, что усложняет эффективное использование суммарной производительности системы. 

\clearpage
\subparagraph{Облачная архитектура} \hfill

\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{design/archCloud}
\caption{Облачная архитектура АИС}
\label{figure:archCloud}
\end{figure}

Облачная архитектура использует гораздо более высокий уровень абстракции, чем все предыдущие архитектуры, так как код приложения не привязан к ЭВМ, на которой он будет выполняться, и может мигрировать между серверами по мере надобности для достижения равномерной загрузки кластера серверов. 

Недостатками данной архитектуры является очень высокая сложность реализации и сложность обеспечения безопасности данных.

\subparagraph{Сравнение вариантов архитектуры АИС} \hfill

\begin{table}[h!]
\centering
\caption{Сравнение вариантов архитектуры АИС}
\label{table:archChoice}
\hatex{weightedArch weightedSummTabular}
\end{table}

\begin{table}[h!]
\centering
\caption{Сравнение вариантов архитектуры АИС с нормированными оценками}
\label{table:archChoiceNorm}
\hatex{weightedArch weightedSummTabular'}
\end{table}

\paragraph{Выбор клиентского языка программирования} \hfill

\paragraph{Выбор библиотеки для основы интерфейса} \hfill

\paragraph{Выбор библиотеки для рубрикатора} \hfill

\paragraph{Выбор библиотеки для графиков} \hfill

\paragraph{Выбор серверного языка программирования} \hfill

\paragraph{Выбор серверной библиотеки} \hfill

\paragraph{Выбор библиотеки полнотекстового поиска} \hfill

\paragraph{Выбор СУБД} \hfill
